<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Race Track</title>
    <style>
        canvas {
            border: 1px solid #000;
            background-color: #ccc;
            display: block;
            margin: 0 auto;
        }

        button {
            display: block;
            margin: 10px auto;
        }
    </style>
</head>
<body>
    <canvas id="raceTrack" width="800" height="600"></canvas>
    <button id="getDataButton">Get Data</button>
    <button id="stopDataButton" disabled>Stop Data</button>
    <button id="saveJsonButton" disabled>Save JSON</button>
    <button id="saveCsvButton" disabled>Save CSV</button>
    <button id="trainModelButton" disabled>Train Model</button>
    <button id="runModelButton" disabled>Run Model</button>
    <div id="data" style="margin: 10px auto; width: 400px; height: 200px; overflow: auto;"></div>

    <script>
        const canvas = document.getElementById("raceTrack");
        const context = canvas.getContext("2d");
        const ballRadius = 10;
        const roadColor = "#333";
        const roadWidth = 400;
        const roadHeight = 200;
        const roadX = 200;
        const roadY = 200;
        let ballX = roadX + ballRadius;
        let ballY = roadY + roadHeight - ballRadius;
        let isLogging = false;
        let dataLog = [];
        let isDragging = false;
        let isModelTrained = false;
        let trainedModel;

        const getDataButton = document.getElementById("getDataButton");
        const stopDataButton = document.getElementById("stopDataButton");
        const saveJsonButton = document.getElementById("saveJsonButton");
        const saveCsvButton = document.getElementById("saveCsvButton");
        const trainModelButton = document.getElementById("trainModelButton");
        const runModelButton = document.getElementById("runModelButton");
        const dataDiv = document.getElementById("data");

        // Function to clear the canvas
        function clearCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Function to draw the race track
        function drawRaceTrack() {
            context.fillStyle = roadColor;
            context.fillRect(roadX, roadY, roadWidth, roadHeight);

            // Draw the starting line
            context.strokeStyle = "#000";
            context.beginPath();
            context.moveTo(roadX, roadY);
            context.lineTo(roadX, roadY + roadHeight);
            context.lineWidth = 2;
            context.stroke();
        }

        // Function to draw the ball
        function drawBall(x, y) {
            context.fillStyle = "#ff0000";
            context.beginPath();
            context.arc(x, y, ballRadius, 0, Math.PI * 2);
            context.fill();
        }

        // Function to log data
        function logData() {
            if (isLogging) {
                dataLog.push({ x: ballX, y: ballY });
                dataDiv.innerText = "x,y\n" + dataLog.map(entry => `${entry.x},${entry.y}`).join("\n");
            }
        }

        getDataButton.addEventListener("click", () => {
            if (!isLogging) {
                isLogging = true;
                dataLog = [];
                dataLog.push({ x: ballX, y: ballY });
                dataDiv.innerText = "x,y\n"; // Clear the data div
                logData();
                getDataButton.disabled = true;
                stopDataButton.disabled = false;
                saveJsonButton.disabled = true;
                saveCsvButton.disabled = true;
                trainModelButton.disabled = true;
                setInterval(logData, 500);
            }
        });

        stopDataButton.addEventListener("click", () => {
            isLogging = false;
            getDataButton.disabled = false;
            stopDataButton.disabled = true;
            saveJsonButton.disabled = false;
            saveCsvButton.disabled = false;
            trainModelButton.disabled = false;
        });

        canvas.addEventListener("mousedown", (event) => {
            const mouseX = event.clientX - canvas.getBoundingClientRect().left;
            const mouseY = event.clientY - canvas.getBoundingClientRect().top;

            if (isLogging) {
                if (
                    mouseX >= ballX - ballRadius &&
                    mouseX <= ballX + ballRadius &&
                    mouseY >= ballY - ballRadius &&
                    mouseY <= ballY + ballRadius
                ) {
                    isDragging = true;
                }
            }
        });

        canvas.addEventListener("mousemove", (event) => {
            if (isDragging) {
                ballX = event.clientX - canvas.getBoundingClientRect().left;
                ballY = event.clientY - canvas.getBoundingClientRect().top;
                clearCanvas();
                drawRaceTrack();
                drawBall(ballX, ballY);
            }
        });

        canvas.addEventListener("mouseup", () => {
            isDragging = false;
        });

        // Initial drawing of the race track and ball
        clearCanvas();
        drawRaceTrack();
        drawBall(ballX, ballY);

        // Define and compile a simple model (you can use more complex models)
        trainModelButton.addEventListener("click", () => {
            if (dataLog.length < 2) {
                alert("Please log more data before training.");
                return;
            }

            const xs = tf.tensor2d(dataLog.map(entry => [entry.x, entry.y]));
            const ys = tf.tensor2d(dataLog.map(entry => [entry.x + 10, entry.y]));

            // Define and compile a simple model (you can use more complex models)
            trainedModel = tf.sequential();
            trainedModel.add(tf.layers.dense({ units: 10, activation: 'relu', inputShape: [2] }));
            trainedModel.add(tf.layers.dense({ units: 2, activation: 'linear' }));
            trainedModel.compile({
                optimizer: tf.train.adam(),
                loss: 'meanSquaredError'
            });

            // Train the model
            trainedModel.fit(xs, ys, {
                epochs: 100,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        console.log(`Epoch ${epoch}, loss: ${logs.loss}`);
                    }
                }
            }).then(info => {
                console.log('Model training complete.');
                saveJsonButton.disabled = false;
                runModelButton.disabled = false;
            });
        });

        // Function to save the trained model
        saveJsonButton.addEventListener("click", () => {
            trainedModel.save('downloads://my_model');
        });

        // Function to run the model predictions and move the ball
        runModelButton.addEventListener("click", runModel);
        const intervalMs = 100;

        function runModel() {
            if (!isModelTrained) {
                alert("Please train the model first.");
                return;
            }

            const prediction = trainedModel.predict(tf.tensor2d([[ballX, ballY]])).dataSync();
            ballX = prediction[0];
            ballY = prediction[1];

            clearCanvas();
            drawRaceTrack();
            drawBall(ballX, ballY);

            if (ballX > roadX + roadWidth || ballX < roadX) {
                alert("Race completed!");
                runModelButton.disabled = true;
            }
        }
    </script>
</body>
</html>
